<!DOCTYPE html>

<head>
    <meta charset="utf-8">
    <script src="https://d3js.org/d3.v4.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/4.6.2/pixi.js"></script>
    <script src="https://www.dl.dropboxusercontent.com/s/ypn96v67r6ci1lq/tsne.js"></script>
    <script src="https://www.dl.dropboxusercontent.com/s/o3cvzik40g74a08/distance-to-polygon.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
    <style>
        .nodes circle {
        stroke-width: 1.5px;
        }

        body {
            margin: 8px;
            position: fixed;
            top: 0;
            right: 0;
            bottom: 0;
            left: 0;
        }

        h1 {
            margin: 0px;
            font-family: "Lucida Sans Unicode";
            left: 0px;
        }

    </style>
</head>

<body>
  <h1 style="font-family:Lucida Sans Unicode;"> tSNE Magyarország</h1>
  <div style = "position: absolute; top: 80px;">
    Adatkészlet <br> <select id="dropdown" style="width: 120px;">
      <option value='noGeo'>Városok</option>
      <option value='https://www.dl.dropboxusercontent.com/s/emgpfdsw4ct9mcd/balesetek.csv'>Balesetek</option>
      <option value='https://www.dl.dropboxusercontent.com/s/niuzz20nbr5r8yt/kereskedelem.csv'>Kereskedelem</option>
      <option value='https://www.dl.dropboxusercontent.com/s/s4jhn8hlb6gy76k/lakásállomány.csv'>Lakásállomány</option>
      <option value='https://www.dl.dropboxusercontent.com/s/aazva4mblap92cd/népmozgalom.csv'>Népmozgalom</option>
      <option value='https://www.dl.dropboxusercontent.com/s/xp8a4bg4dz8zta8/közművelődés.csv'>Közművelődés</option>
    </select>
    <form>
      <br>
     Perplexity <br> <input type="number" name="perplexity" value = 60 style="width: 120px;" >
     <br><br>
     Erőtér erőssége <br> <input type="number" name="forceFieldStrength" value = 0.35 style="width: 120px;" >
    </form>
  </div>
  <div id="canvasDOM" style="position: absolute; top: 10px; left: 60px; z-index: -1">

  </div>
  <img src="https://www.dl.dropboxusercontent.com/s/a5vxjrp7e4m5er0/legend.PNG" alt="Smiley face" height="147" width="172" style="position: absolute; top: 440px; left: 0px;">
  <script>
    var perplexity = 60;
    var forceFieldStrength = 0.35;
    var dataPath;
    var forceBool;
    $('select').on('change', function() {
      clearPage();
      dataPath = this.value;
      if (this.value !== "noGeo"){
        generateViz(this.value, true);
      } else {
        generateViz('https://www.dl.dropboxusercontent.com/s/emgpfdsw4ct9mcd/balesetek.csv',false);
      }
    });

    $('input[name="perplexity"]').on('change', function() {
      clearPage();
      generateViz(dataPath, true);
      perplexity = this.value;
    });

    $('input[name="forceFieldStrength"]').on('change', function() {
      forceFieldStrength = this.value;
    });


    var forcetsne;
    var data;
    var nodes;
    var model;
    var numData;
    var dists;
    var stage;
    var renderer;
    var flatHuPolygon2;
    var pos;
    var normScale;


    function generateViz(dataPath, forcesBoolean){
      var width = 1000,
      height = 600,
      margin = 60,
      countrypadding = 80,
      scalepop = d3.scaleSqrt().domain([0, 1740041]).range([0.2, 30]),
      scalecountry = (function() {
          var scale = d3.scaleOrdinal(d3.schemeCategory10);
          return function(num) {
            return parseInt(scale(num).slice(1), 16);
          };
      })();
      var i = 0;

      function euclideanDistance(pointA, pointB){
        var distance = 0;
        var sumSqCoordDiff = 0;
        var n = pointA.length;
        if (pointA.length != pointB.length){
          throw "two points do not have the same number of dimensions";
        } else {
          for (m = 0; m < n; m++) {
            sumSqCoordDiff += Math.pow(pointA[m] - pointB[m], 2);
          }
          distance = Math.sqrt(sumSqCoordDiff);
          return distance;
        }
      }

      

      stage = new PIXI.Container();
      renderer = PIXI.autoDetectRenderer(width, height, {antialias: !0, transparent: !0, resolution: 1, roundPixels: 1});
      canvasDom = document.getElementById("canvasDOM").appendChild(renderer.view);
      //https://www.dropbox.com/s/bx5zx6rgpbk4tjn/hungary_polygon.csv?dl=0
      
      //document.write("#2 complete")
      d3.csv('https://www.dl.dropboxusercontent.com/s/bx5zx6rgpbk4tjn//hungary_polygon.csv', function(hungaryApproxPolygon){
        d3.csv('https://www.dl.dropboxusercontent.com/s/mgcl0w6mlrpv2n3//hungary_polygon_manypoints.csv', function(hungaryPolygon){
          d3.csv(dataPath, function (cities) {
            // Transform the data read from the csv
            cols = cities.columns;
            data = cities.map(function(d) {
              var returnArray = [];
              returnArray.push(
                +d.x_long, 
                +d.y_lat, 
                d['Megnevezés'], 
                +d['Népesség'], 
                +d['Régió']);
              cols.slice(5).forEach(function(f,i){
                returnArray.push(+d[f]/+d["Népesség"]*10000);
                //returnArray.push(+d[f]);
              })
              return returnArray;
              });

            normScales = []
            for (i = 5; i < cols.length; i++){
              normScales.push(d3.scaleLinear()
                .domain(d3.extent(data.map(function(r){
                  return r[i];
              }))))
            }
            console.log(normScales.map(function(s){return s.domain()}))
            console.log(data);
            dataIndices = [5, 6, 7, 8];
            // Initialize the model
            model = new tsnejs.tSNE({
              epsilon: 10,
              dim: 2,
              perplexity: perplexity,
            });

            function filterByIndices(array, indices){
              var filteredArray = [];
              for (i=0; i< indices.length; i++){
                filteredArray.push(array[indices[i]]);
              }
              return filteredArray;
            }

            //numData = data.map(function(d){return filterByIndices(d, dataIndices);});
            numData =data.map(function(d){return d.slice(5);});
            dists = numData.map(
              function(d) {
                return numData.map(
                  function(e) {
                    return euclideanDistance(d, e);
                    //return d3.geoDistance(d, e);
                  }
                );
              }
            );
            console.log(numData);
            console.log(dists);
            model.initDataDist(dists);
            for (i=0; i<100; i++){
              model.step();
            }

            // Create scales for centering the viz
            centerx = d3.scaleLinear()
              .range([margin, width - margin])
              .domain(d3.extent(data.map(function(d) {return d.x_long;})));
            centery = d3.scaleLinear()
              .range([margin, height - margin])
              .domain(d3.extent(data.map(function(d) {return d.y_lat;})));
            huXScale = d3.scaleLinear()
              .range([margin, width - margin])
              .domain(d3.extent(hungaryPolygon.map(function (p) {return +p.x;})));
            huYScale = d3.scaleLinear()
              .range([margin, height - margin])
              .domain(d3.extent(hungaryPolygon.map(function (p) {return +p.y;})).reverse());

            huXScaleApprox = d3.scaleLinear()
              .range([(huXScale.range()[0]-width/2) * 0.8 + width/2, (huXScale.range()[1]-width/2) * 0.8 + width/2])
              .domain(d3.extent(hungaryPolygon.map(function (p) {return +p.x;})));
            huYScaleApprox = d3.scaleLinear()
              .range([(huYScale.range()[0]-height/2) * 0.8 + height/2, (huYScale.range()[1]-height/2) * 0.8 + height/2])
              .domain(d3.extent(hungaryPolygon.map(function (p) {return +p.y;})).reverse());

            hungaryPolygon = hungaryPolygon.map(function(p) {return [huXScale(p.x), huYScale(p.y)];});
            //hungaryApproxPolygon = hungaryApproxPolygon.map(function(p) {return [huXScaleApprox(p['x']), huYScaleApprox(p['y'])];});
            hungaryApproxPolygon = hungaryApproxPolygon.map(function(p) {return [huXScale(p.x), huYScale(p.y)];});

            console.log(distToPoly.distanceToPolygon([0, 0], hungaryApproxPolygon));
            // draw the border polygon(s)
            /*
            var flatHuPolygon = [].concat.apply([], hungaryPolygon);
            hungary_pixi = new PIXI.Graphics();
            hungary_pixi.lineStyle(1.5, 0x000000, 1);
            hungary_pixi.drawPolygon(flatHuPolygon);
            stage.addChild(hungary_pixi);*/

            flatHuPolygon2 = [].concat.apply([], hungaryApproxPolygon);
            hungary_pixi2 = new PIXI.Graphics();
            hungary_pixi2.lineStyle(1, 0x000000, 0.8);
            hungary_pixi2.drawPolygon(flatHuPolygon2);
            stage.addChild(hungary_pixi2);

            console.log(huXScale(data[0][0]));
            forcetsne = d3.forceSimulation(data.map(function(d) {
              return d.x = huXScale(+d[0]), d.y = huYScale(+d[1]), d.type = 'city', d.dist = 0, d;
            }));
            nodes = forcetsne.nodes();

            console.log(nodes);
            var alpha = 0.008;
            if (forcesBoolean === false) { alpha = 0;}
            forcetsne.alphaDecay(0.0001)
              .alpha(alpha)
              //.force("center", d3.forceCenter(width / 2, height / 2))
              /*
              .force('repulsion', d3.forceManyBody()
                .strength(function(d){
                  return scalepop(d[3])*-30 + -10;
                })
                .distanceMin(10)
                .distanceMax(50)
                .theta(2)
              )*/
              .on("tick", ticked)
              
              .force('tsne', function (alpha) {               
                i += 1;

                model.step();
                
                pos = model.getSolution();
                
                
                centerx.domain(d3.extent(pos.map(function(d) {return d[0];})));
                centery.domain(d3.extent(pos.map(function(d) {return d[1];})));
                
                k=1.2;
                nodes.forEach(function(d, i) {
                  if (d.type==="city"){
                    d.vx += k * alpha * (centerx(pos[i][0]) - d.x);
                    d.vy += k * alpha * (centery(pos[i][1]) - d.y);
                  }
                });        

                var selectedCities = "";
                selectedNodes.forEach(function(n){
                  if (selectedCities.length==0){
                    selectedCities = n[2];
                  } else {
                    selectedCities += ", " + n[2]
                  }
                });
                content = [
                  "centerx.domain: " + centerx.domain(),
                  "d3.extent(d.x): " + d3.extent(data.map(function(d){return d.x;})),
                  "centerx.range: " + centerx.range(),
                  "centery.domain: " + centery.domain(),
                  "d3.extent(d.y): " + d3.extent(data.map(function(d){return d.y;})),
                  "centery.range: " + centery.range()
                ];
                d3.selectAll("p").each(function(p,i){
                  //d3.select(this).text(content[i]);
                  d3.select(this).text(selectedCities)
                });
              });
              
            var maxDist = width/2;
            var forceFieldScale = d3.scalePow()
              .exponent(0.4)
              .domain([maxDist, 1])
              .range([0, 1]);
            
            forcetsne.force("forcefield", function(alpha){
              var distMax = maxDist;
              nodes.forEach(function(d){
                if(d.type === "city"){
                  var k1 = forceFieldStrength;
                  var k2 = 1.3;
                  if (forceFieldStrength==0){
                    k2 = 0;
                  }
                  var dist = distToPoly.distanceToPolygon([d.x, d.y], hungaryApproxPolygon);
                  dist = Math.max(dist, 1);
                  var trDist = forceFieldScale(dist);
                  d.dist = dist;
                  if (d3.polygonContains(hungaryApproxPolygon, [d.x, d.y]) === true){
                    if (dist < distMax){
                      d.vx += k1 * alpha * trDist * (width/2 - d.x);
                      d.vy += k1 * alpha * trDist * (height/2 - d.y);
                    }
                  } else if (d3.polygonContains(hungaryApproxPolygon, [d.x, d.y]) === false){
                    d.vx += alpha * k2 * trDist * (width/2 - d.x);
                    d.vy += alpha * k2 * trDist * (height/2 - d.y);
                  }
                }
              });
            });
            
            //create PIXI graphics for nodes
            nodes.forEach(function(d) {
              if (d.type==="city") {
                d.gfx = new PIXI.Graphics();
                d.gfx.lineStyle(1.5, scalecountry(d[4]));
                d.gfx.beginFill(scalecountry(d[4]),0.8);
                d.gfx.drawCircle(0, 0, scalepop(d[3]));
                stage.addChild(d.gfx);
              } else if (d.type === "border"){
                d.gfx = new PIXI.Graphics();
                d.gfx.lineStyle(1.5, 0x000000, 0.8);
                d.gfx.beginFill(0x000000);
                d.gfx.drawCircle(0, 0, 5);
                stage.addChild(d.gfx);
              }
            });

            // setup drag actions
            d3.select(renderer.view)
                    .call(d3.drag()
                        .container(renderer.view)
                        //.subject(function() {return forcetsne.find(d3.event.x, d3.event.y);})
                        .on('start', dragstarted)
                        .on('drag', dragged)
                        .on('end', dragended));

            // ticks will reposition the PIXI graphics and render the stage
            function ticked() {
                nodes.forEach(function(d) {
                    d.gfx.position = new PIXI.Point(d.x,d.y);
                });
                renderer.render(stage);
            }

            var ptl = null
            var pbr = null
            var selector = {selpol: null, gfx: new PIXI.Graphics()}
            var selectedNodes = []
            function dragstarted() {
              //if (!d3.event.active) forcetsne.alphaTarget(0.3).restart();
              selector.selPol = null
              selectedNodes = []
              ptl = [d3.event.x, d3.event.y];
              pbr = ptl
              console.log(ptl);
            }

            function dragged() {
              pbr = [d3.event.x, d3.event.y];
              selector.selPol = [pbr, [pbr[0], ptl[1]], ptl, [ptl[0], pbr[1]], pbr]
              var flatpolygon = [].concat.apply([], selector.selPol);
              selector.gfx.clear()
              selector.gfx.lineStyle(1, 0x000000, 0.8);
              selector.gfx.beginFill(0x000000, 0.25);
              selector.gfx.drawPolygon(flatpolygon);
              stage.addChild(selector.gfx);
              renderer.render(stage);
            }

            function dragended() {
              //if (!d3.event.active) forcetsne.alphaTarget(0);
              //selPol = [pbr, [pbr[0], ptl[1]], ptl, [ptl[0], pbr[1]], pbr];
              ptl = null;
              pbr = null;
              nodes.forEach(function(d){
                if (d3.polygonContains(selector.selPol, [d.x, d.y])){
                  selectedNodes.push(d)
                  d.gfx.clear()
                  d.gfx.lineStyle(2, 0x000000);
                  d.gfx.beginFill(scalecountry(d[4]),0.8);
                  d.gfx.drawCircle(0, 0, scalepop(d[3])+3);
                  d.gfx.position = new PIXI.Point(d.x,d.y)
                } else {
                  d.gfx.clear()
                  d.gfx.lineStyle(1, scalecountry(d[4]));
                  d.gfx.beginFill(scalecountry(d[4]),0.8);
                  d.gfx.drawCircle(0, 0, scalepop(d[3]));
                  d.gfx.position = new PIXI.Point(d.x,d.y)
                }
              })
              renderer.render(stage);
              console.log(selectedNodes)
              selector.gfx.clear()
            }

          });
        });
      });
    }
    generateViz('https://www.dl.dropboxusercontent.com/s/emgpfdsw4ct9mcd/balesetek.csv',false);
    debugdiv = d3.select("body").append("div").attr("style", "position: absolute; top: 650px; left: 0px;").append("p").text("");

    function clearPage(){
      //d3.selectAll("div").remove();
      d3.selectAll("canvas").remove();
      forcetsne.stop();
    }
  </script>
</body>